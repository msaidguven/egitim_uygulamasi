-- supabase/migrations/0007_bulk_question_creation.sql
-- FINAL ATOMIC VERSION - UPDATED FOR SIMPLIFIED BLANK_OPTIONS SCHEMA & TRUE/FALSE QUESTIONS

-- Adım 1: 'question_usages' tablosu (Değişiklik yok, sadece var olmalı)
CREATE TABLE IF NOT EXISTS public.question_usages (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    question_id BIGINT NOT NULL REFERENCES public.questions(id) ON DELETE CASCADE,
    topic_id BIGINT NOT NULL REFERENCES public.topics(id) ON DELETE CASCADE,
    usage_type TEXT NOT NULL CHECK (usage_type IN ('weekly', 'topic_end')),
    display_week INT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(question_id, topic_id, usage_type)
);

-- Adım 2: 'bulk_create_questions' RPC fonksiyonunu SİL ve YENİDEN OLUŞTUR.
DROP FUNCTION IF EXISTS public.bulk_create_questions(bigint, text, int, jsonb);

CREATE OR REPLACE FUNCTION bulk_create_questions(
    p_topic_id BIGINT,
    p_usage_type TEXT,
    p_display_week INT,
    p_questions_json JSONB
)
RETURNS void
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    question_data JSONB;
    pair_data JSONB;
    choice_data JSONB;
    blank_option_data JSONB;
    question_type_text TEXT;
    v_question_type_id SMALLINT;
    new_question_id BIGINT;
BEGIN
    FOR question_data IN SELECT * FROM jsonb_array_elements(p_questions_json->'questions')
    LOOP
        -- Adım 1: Soru tipini belirle
        v_question_type_id := (question_data->>'question_type_id')::SMALLINT;
        SELECT code INTO question_type_text FROM public.question_types WHERE id = v_question_type_id;
        IF NOT FOUND THEN RAISE EXCEPTION 'Geçersiz "question_type_id": %', v_question_type_id; END IF;

        -- Adım 2: Ana 'questions' tablosuna yeni soruyu ekle.
        -- ********************************************************************
        -- DEĞİŞİKLİK BURADA: 'correct_answer' sütunu eklendi.
        -- ********************************************************************
        INSERT INTO public.questions (question_type_id, question_text, difficulty, score, correct_answer)
        VALUES (
            v_question_type_id,
            question_data->>'question_text',
            (question_data->>'difficulty')::SMALLINT,
            (question_data->>'score')::SMALLINT,
            (question_data->>'correct_answer')::BOOLEAN -- Bu satır eklendi.
        )
        RETURNING id INTO new_question_id;
        -- ********************************************************************
        -- DEĞİŞİKLİK SONU
        -- ********************************************************************

        -- Adım 3: 'question_usages' tablosuna kullanım bilgisini ekle.
        IF p_usage_type = 'weekly' THEN
            INSERT INTO public.question_usages (question_id, topic_id, usage_type, display_week)
            VALUES (new_question_id, p_topic_id, p_usage_type, p_display_week);
        ELSE
            INSERT INTO public.question_usages (question_id, topic_id, usage_type)
            VALUES (new_question_id, p_topic_id, p_usage_type);
        END IF;

        -- Adım 4: Soru tipine özel tablolara ekleme yap.
        IF question_type_text = 'multiple_choice' THEN
            FOR choice_data IN SELECT * FROM jsonb_array_elements(question_data->'choices')
            LOOP
                INSERT INTO public.question_choices (question_id, choice_text, is_correct)
                VALUES (new_question_id, choice_data->>'text', (choice_data->>'is_correct')::BOOLEAN);
            END LOOP;

        ELSIF question_type_text = 'fill_blank' THEN
            IF question_data->'blank' ? 'options' THEN
                FOR blank_option_data IN SELECT * FROM jsonb_array_elements(question_data->'blank'->'options')
                LOOP
                    INSERT INTO public.question_blank_options (question_id, option_text, is_correct)
                    VALUES (new_question_id, blank_option_data->>'text', (blank_option_data->>'is_correct')::BOOLEAN);
                END LOOP;
            END IF;

        ELSIF question_type_text = 'classical' THEN
             IF question_data ? 'model_answer' THEN
                INSERT INTO public.question_classical (question_id, model_answer)
                VALUES (new_question_id, question_data->>'model_answer');
             END IF;
        ELSIF question_type_text = 'matching' THEN
            FOR pair_data IN SELECT * FROM jsonb_array_elements(question_data->'pairs')
            LOOP
                INSERT INTO public.question_matching_pairs (question_id, left_text, right_text)
                VALUES (new_question_id, pair_data->>'left_text', pair_data->>'right_text');
            END LOOP;
        END IF;
    END LOOP;
END;
$$;

-- Adım 3: RLS politikaları (Değişiklik yok, sadece var olmalı)
ALTER TABLE public.question_usages ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Allow public read access on question_usages" ON public.question_usages;
CREATE POLICY "Allow public read access on question_usages"
ON public.question_usages
FOR SELECT
TO authenticated
USING (true);

DROP POLICY IF EXISTS "Allow admins to manage question_usages" ON public.question_usages;
CREATE POLICY "Allow admins to manage question_usages"
ON public.question_usages
FOR ALL
TO authenticated
USING ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'admin')
WITH CHECK ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'admin');
