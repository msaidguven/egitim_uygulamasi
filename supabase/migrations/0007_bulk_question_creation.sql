-- supabase/migrations/0007_bulk_question_creation.sql
-- Bu dosya, toplu soru ekleme özelliği için gerekli veritabanı şeması
-- değişikliklerini ve RPC fonksiyonunu içerir.
-- Supabase projenizdeki SQL Editor'de çalıştırılmalıdır.

-- Adım 1: 'question_usages' tablosunu oluştur.
-- Bu tablo, bir sorunun hangi konuda, ne amaçla ve hangi hafta
-- kullanılacağını belirtir.
CREATE TABLE IF NOT EXISTS public.question_usages (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    question_id BIGINT NOT NULL REFERENCES public.questions(id) ON DELETE CASCADE,
    topic_id BIGINT NOT NULL REFERENCES public.topics(id) ON DELETE CASCADE,
    usage_type TEXT NOT NULL CHECK (usage_type IN ('weekly', 'topic_end')),
    start_week INT,
    end_week INT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    -- Bir sorunun belirli bir konu için yalnızca bir kez kullanıldığından emin ol.
    UNIQUE(question_id, topic_id, usage_type)
);

-- Adım 1.1: Eşleştirme soruları için 'question_matching_pairs' tablosunu oluştur.
-- UYARI: Bu tablo zaten varsa, bu komut hata verebilir. db_schema.md'ye göre hareket edin.
-- CREATE TABLE IF NOT EXISTS public.question_matching_pairs (
--   id bigint GENERATED ALWAYS AS IDENTITY NOT NULL,
--   question_id bigint NOT NULL,
--   left_text text NOT NULL,
--   right_text text NOT NULL,
--   order_no integer NOT NULL DEFAULT 0,
--   match text NOT NULL,
--   stem text NOT NULL,
--   CONSTRAINT question_matching_pairs_pkey PRIMARY KEY (id),
--   CONSTRAINT fk_qmp_question FOREIGN KEY (question_id) REFERENCES public.questions(id)
-- );


-- Adım 2: 'bulk_create_questions' RPC fonksiyonunu oluştur veya güncelle.
-- Bu fonksiyon, bir JSON array alarak birden çok soruyu tek seferde veritabanına ekler.
CREATE OR REPLACE FUNCTION bulk_create_questions(
    p_topic_id BIGINT,
    p_usage_type TEXT,
    p_start_week INT,
    p_end_week INT,
    p_questions_json JSONB
)
RETURNS JSONB
LANGUAGE plpgsql
-- SECURITY DEFINER: Bu fonksiyonun, onu oluşturan kullanıcının (admin)
-- yetkileriyle çalışmasını sağlar. Bu, RLS politikalarını atlayarak
-- veri eklemek için önemlidir.
SECURITY DEFINER
AS $$
DECLARE
    question_data JSONB;
    pair_data JSONB;
    question_type_text TEXT;
    v_question_type_id SMALLINT;
    new_question_id BIGINT;
    choice_data JSONB;
    error_details JSONB := '[]'::jsonb;
    question_index INT := 0;
BEGIN
    -- JSON array içindeki her bir soru objesi için döngü başlat.
    FOR question_data IN SELECT * FROM jsonb_array_elements(p_questions_json->'questions')
    LOOP
        BEGIN
            -- Adım 1: Soru tipini belirle (ID veya metin olarak)
            v_question_type_id := (question_data->>'question_type_id')::SMALLINT;
            question_type_text := question_data->>'question_type';

            IF v_question_type_id IS NULL AND question_type_text IS NULL THEN
                RAISE EXCEPTION '"question_type" veya "question_type_id" alanlarından en az biri zorunludur.';
            ELSIF v_question_type_id IS NOT NULL THEN
                -- ID varsa, metin karşılığını bul
                SELECT code INTO question_type_text FROM public.question_types WHERE id = v_question_type_id;
                IF NOT FOUND THEN
                    RAISE EXCEPTION 'Geçersiz "question_type_id": %', v_question_type_id;
                END IF;
            ELSE
                -- Metin varsa, ID karşılığını bul
                SELECT id INTO v_question_type_id FROM public.question_types WHERE code = question_type_text;
                IF NOT FOUND THEN
                    RAISE EXCEPTION 'Geçersiz "question_type": %', question_type_text;
                END IF;
            END IF;

            -- Adım 2: Ana 'questions' tablosuna yeni soruyu ekle.
            INSERT INTO public.questions (question_type_id, question_text, difficulty, score)
            VALUES (
                v_question_type_id,
                question_data->>'question_text',
                (question_data->>'difficulty')::SMALLINT,
                (question_data->>'score')::SMALLINT
            ) RETURNING id INTO new_question_id;

            -- Adım 3: 'question_usages' tablosuna kullanım bilgisini ekle.
            INSERT INTO public.question_usages (question_id, topic_id, usage_type, start_week, end_week)
            VALUES (new_question_id, p_topic_id, p_usage_type, p_start_week, p_end_week);

            -- Adım 4: Soru tipine özel tablolara ekleme yap.
            IF question_type_text = 'multiple_choice' THEN
                FOR choice_data IN SELECT * FROM jsonb_array_elements(question_data->'choices')
                LOOP
                    INSERT INTO public.question_choices (question_id, choice_text, is_correct)
                    VALUES (
                        new_question_id,
                        COALESCE(choice_data->>'choice_text', choice_data->>'text'), -- İki formatı da destekle
                        (choice_data->>'is_correct')::BOOLEAN
                    );
                END LOOP;
            ELSIF question_type_text = 'blank' THEN
                INSERT INTO public.question_blanks (question_id, correct_answer)
                VALUES (new_question_id, (question_data->>'correct_answer')::TEXT); -- Gelen veriyi TEXT'e çevir
            ELSIF question_type_text = 'classical' THEN
                INSERT INTO public.question_classical (question_id, model_answer)
                VALUES (new_question_id, question_data->>'model_answer');
            ELSIF question_type_text = 'matching' THEN
                FOR pair_data IN SELECT * FROM jsonb_array_elements(question_data->'pairs')
                LOOP
                    INSERT INTO public.question_matching_pairs (question_id, left_text, right_text, order_no)
                    VALUES (
                        new_question_id,
                        COALESCE(pair_data->>'left_text', ''),
                        COALESCE(pair_data->>'right_text', ''),
                        0 -- Default value for order_no, assuming it exists and is NOT NULL with a default.
                    );
                END LOOP;            END IF;

        EXCEPTION WHEN OTHERS THEN
            -- Herhangi bir soruyu eklerken hata olursa, hatayı logla ve devam et.
            error_details := error_details || jsonb_build_object(
                'index', question_index,
                'question_text', question_data->>'question_text',
                'error', SQLERRM
            );
        END;
        question_index := question_index + 1;
    END LOOP;

    -- İşlem tamamlandığında, varsa hataları içeren bir JSON objesi döndür.
    RETURN jsonb_build_object('status', 'completed', 'errors', error_details);
END;
$$;

-- Adım 3: Yeni RLS politikalarını 'question_usages' tablosuna ekle.
ALTER TABLE public.question_usages ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Allow public read access on question_usages" ON public.question_usages;
CREATE POLICY "Allow public read access on question_usages"
ON public.question_usages
FOR SELECT
TO authenticated -- veya 'public'
USING (true);

DROP POLICY IF EXISTS "Allow admins to manage question_usages" ON public.question_usages;
CREATE POLICY "Allow admins to manage question_usages"
ON public.question_usages
FOR ALL
TO authenticated
USING ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'admin')
WITH CHECK ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'admin');

-- Adım 4: Yeni RLS politikalarını 'question_matching_pairs' tablosuna ekle.
-- ALTER TABLE public.question_matching_pairs ENABLE ROW LEVEL SECURITY;
-- 
-- DROP POLICY IF EXISTS "Allow public read access on question_matching_pairs" ON public.question_matching_pairs;
-- CREATE POLICY "Allow public read access on question_matching_pairs"
-- ON public.question_matching_pairs
-- FOR SELECT
-- TO authenticated
-- USING (true);
-- 
-- DROP POLICY IF EXISTS "Allow admins to manage question_matching_pairs" ON public.question_matching_pairs;
-- CREATE POLICY "Allow admins to manage question_matching_pairs"
-- ON public.question_matching_pairs
-- FOR ALL
-- TO authenticated
-- USING ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'admin')
-- WITH CHECK ((SELECT role FROM public.profiles WHERE id = auth.uid()) = 'admin');